
## 导言

自动驾驶汽车是如何“看”懂路况的？手机上的面部识别功能又是如何实现的？这些神奇的应用背后，都离不开一项关键技术——卷积神经网络（Convolutional Neural Networks，简称 CNN）。

这期视频来自麻省理工学院（MIT）的 6.S191 深度学习入门课程，由 Alexander Amini 讲授，专门讲解 CNN 在计算机视觉领域的应用。如果你对深度学习感兴趣，特别是想了解计算机如何“看”世界，那么这期视频绝对不容错过。

Amini 老师首先会带你回顾计算机视觉的基本概念，解释计算机是如何表示和处理图像的。接着，他会深入讲解 CNN 的核心思想——卷积操作。你会了解到，卷积操作就像一个“滤波器”，能够在图像中提取出关键的特征，比如边缘、角点、纹理等。

视频中不仅有理论讲解，还有生动的实例演示。Amini 老师会逐步拆解 CNN 的各个组成部分，包括卷积层、非线性激活函数、池化层等，让你彻底理解 CNN 的工作原理。此外，他还展示了如何用代码构建一个简单的 CNN 模型，并将其应用于图像分类、目标检测、语义分割等实际任务中。

值得一提的是，视频还特别强调了 CNN 与传统机器学习方法的区别，以及深度学习在特征提取方面的优势。通过学习这期视频，你将对 CNN 有一个全面而深入的认识，为进一步探索深度学习在计算机视觉领域的应用打下坚实的基础。 

> **视频链接**：https://www.youtube.com/watch?v=oGpzWAlP5p0
>  
>  *如果你想获得讲座的幻灯片和配套实验材料, 可以访问这个网址：* http://introtodeeplearning.com (点击“**阅读原文**”查看)

## 视频纲要

```
讲座纲要
├── 引言 (0:09 - 1:35)
│   ├── 欢迎与课程介绍
│   ├── 计算机视觉的定义：通过观察知道“什么在哪里”
│   └── 视觉的重要性与目标
├── 视觉的复杂性 (1:35 - 3:13)
│   ├── 静态与动态感知
│   ├── 场景细节的整体理解
│   └── 深度学习在计算机视觉中的革命性作用
├── 计算机视觉的应用 (3:13 - 5:27)
│   ├── 广泛应用领域
│   │   ├── 机器人技术
│   │   ├── 自动化
│   │   ├── 移动计算
│   │   ├── 生物学/医疗保健
│   │   ├── 自动驾驶
│   │   └── 辅助功能
│   └── 具体应用实例
│       ├── 面部检测
│       ├── 自动驾驶 (MIT 研究)
│       └── 生物医学图像分析
├── 计算机视觉的技术基础 (5:27 - 7:35)
│   ├── 人类视觉任务的复杂性
│   └── 计算机如何表示图像
│       ├── 灰度图像：单数字像素
│       └── 彩色图像：三数字像素 (RGB)
├── 机器学习任务：回归与分类 (7:35 - 8:18)
│   ├── 回归：输出连续值
│   └── 分类：输出类别标签 (离散类别)
├── 特征检测 (8:18 - 10:16)
│   ├── 理解类别独特性
│   ├── 特征检测的定义
│   └── 分类的两步过程：定义特征 & 检测特征
├── 计算机视觉的难点 (10:16 - 11:46)
│   ├── 特征定义的递归问题
│   ├── 多种变化与适应
│   │   ├── 视角
│   │   ├── 尺度
│   │   ├── 遮挡
│   │   └── 光照
│   └── 分类算法的不变性需求
├── 深度学习的作用 (11:46 - 13:29)
│   ├── 机器学习 vs. 深度学习 (特征定义)
│   └── 神经网络的分层特征学习
│       ├── 模型深度与层次结构
│       └── 隐式学习 vs. 人工构建
├── 全连接网络的问题 (13:29 - 15:46)
│   ├── 图像展平为一维输入
│   ├── 空间信息丢失
│   └── 模型参数过多 & 计算成本高
├── 卷积的引入 (15:46 - 17:53)
│   ├── 保留与利用空间信息
│   ├── 二维图像表示
│   └── 局部连接 (块/patch)
├── 卷积操作 (17:53 - 19:11)
│   ├── 卷积核 (filter)
│   ├── 滑动窗口操作
│   │   ├── 逐元素相乘
│   │   ├── 添加偏置
│   │   └── 应用非线性函数
│   └── 卷积核移动步长
├── 卷积如何提取特征 (19:11 - 22:30)
│    ├── 卷积与特征的关联
│    ├── "X" 检测实例
│    └── "迷你图像" 与 卷积核
├── 卷积的数学表示 (22:30 - 24:52)
│     ├── 卷积操作的数学定义
│     └── 对角线检测实例
├── 卷积的计算 (24:52 - 26:33)
│    ├── 5x5 图像与 3x3 卷积核的卷积计算
│    └── 逐步滑动与计算过程
├── 卷积核的选择和学习 (26:33 - 28:43)
│   ├── 卷积核的重要性
│   ├── 可调参数与输出质量
│   ├── 手动设计卷积核 (边缘检测等)
│   └── 卷积核权重的影响
├── 卷积神经网络 (CNN) (29:36 - 31:49)
│   ├── CNN for 图像分类
│   ├── 学习卷积核/特征
│   └── CNN 的三个主要操作
│        ├── 卷积
│        ├── 非线性
│        └── 池化 (下采样 & 感受野)
├── CNN操作的细节 (31:49 - 34:02)
│     ├── 隐藏层神经元计算
│     ├── 局部连接的重要性
│     ├── 数学表示 (权重矩阵)
│     └── 卷积层与多卷积核 (输出体积)
├── 非线性 (34:02 - 35:20)
│   ├── 非线性函数的作用
│   ├── 表达能力增强
│   └── ReLU (整流线性单元)
├──卷积和非线性的关系 (35:20 - 36:19)
│   ├── 卷积负责检测特征
│   └── 非线性增加特征的表达能力
├── 池化 (38:50 - 40:17)
│   ├── 下采样 & 降维
│   ├── 最大池化 (Max pooling)
│   └── 其他池化方法 (平均池化)
├── 可视化卷积核 (40:22 - 41:53)
│    ├── 模型训练的可视化
│    └── 人脸检测实例：边缘 -> 面部特征 -> 完整结构
├── CNN的两部分 (42:01 - 42:31)
│    ├── 特征提取
│    └── 检测/分类
├── Softmax函数 (42:31 - 42:55)
│   ├── 概率分布转换
│   └── 分类问题的应用
├── 构建CNN代码 (43:01 - 44:31)
│    ├── 定义特征提取部分 (卷积层 & 下采样)
│    ├── 定义分类部分 (展平 & Softmax)
│    └── PyTorch 代码实现
├── 关于超参数的选择 (44:31 - 45:53)
│    ├── patch大小和特征图数量的选择
│    ├── 依赖任务和图像特性
├── 关于训练数据和测试数据的差异 (45:53 - 46:36)
│    ├──  模型泛化能力与训练数据多样性
├── 关于可变形物体 (46:36 - 47:15)
│    ├── 仍然从数据中学习特征
├── CNN的应用扩展 (47:15 - 48:09)
│   ├── 超越分类任务
│   └── 特征提取器 + 不同模型
│       ├── 分类器
│       ├── 目标检测器
│       ├── 分割模型
│       ├── 概率控制模型
│       └── 回归模型
├── 分类 (48:09 - 48:41)
│   ├── 展平 + 分类 (N 个类别)
│   └── 二元诊断实例
├── 目标检测 (48:41 - 50:18)
│   ├── 预测类别、位置 & 边界框
│   └── 模型灵活性需求
├── 目标检测的难点 (50:18 - 50:36)
│   └── 边界框的任意性
├── 朴素方法 (50:36 - 51:49)
│   ├──  随机框与多次CNN
│   └── 计算成本过高
├── 启发式方法 (51:49 - 52:32)
│   ├── "斑点" 检测
│   ├── 仍然很慢
│   └── 特征检测与分类分离
├── R-CNN方法 (52:32 - 54:28)
│   ├── 区域卷积神经网络
│   ├── 学习区域 & 分类
│   └── 区域提议网络 & 共享特征
├── 语义分割 (54:28 - 56:14)
│   ├── 像素级分类
│   ├── 上采样卷积
│   └── 特征提取 + 上采样
├── 自动驾驶 (56:14 - 59:07)
│   ├── 摄像头数据 & 地图数据 -> 控制
│   ├── 连续概率分布 (方向盘角度)
│   └── 卷积、非线性、下采样 -> 特征组合 -> 控制参数学习
└── 总结 (59:07 - 1:00:59)
     ├── CNN 的广泛影响
     ├── 核心技术回顾
     └── 课程内容总结

```


## 讲座实录

### 引言 (0:09 - 1:35)

大家好！欢迎大家回来参加 MIT 深度学习入门课程的第二天。感谢各位的到来！希望大家喜欢第一天的内容。今天，我们要讨论的是我个人最喜欢的一个主题，那就是计算机视觉。我们将探讨如何赋予计算机“看”的能力，这种能力是我们很多人都拥有的，也就是视觉感知的能力。

首先，我们需要了解什么是视觉。视觉是我们人类最重要的感官之一。它让我们能够完成各种各样的事情，从识别和解读人类的情感和面部表情，到在世界上导航，再到操纵物体和周围的世界。今天，我们在这节课上的主要任务就是理解如何让计算机也拥有同样的感官，也就是让它们能够仅仅通过原始的视觉输入，就能理解周围物理世界中有什么。

我喜欢用一个非常简单的定义来描述这种能力，那就是：“通过观察知道‘什么在哪里’”。今天的课程主要关注的是图像，但总的来说，这就是我们要关注的广泛意义上的能力。

### 视觉的复杂性 (1:35 - 3:13)

但实际上，视觉远不止理解“什么在哪里”，它还包含了规划的能力，它不仅仅是一种静态的感知。例如，当我向大家展示这张图片时，你们首先会看到静态的事物，比如路边的汽车和行人。但更重要的是，当你们仔细观察这张图片时，会立刻感受到一种动态感。你们不仅能理解“什么在哪里”，还能理解事物是如何运动的。 你们会明白，即使这两辆车都在路上，其中一辆，也就是左边的白色货车，很可能是完全静止的，因为它停在路边。尽管它们都是汽车，你们也能识别出它们是汽车，但当我们观察这张图片时，对它们的感知是完全不同的。同样，对于路边的这些行人和正在移动的行人也是如此。

视觉不仅仅是理解图像中有什么，还要从整体上理解和解释图像，包括事物如何移动，如何随时间变化。它考虑了场景中的所有细节，我们认为这是理所当然的。当我们观察所有这些事物时，即使是背景中非常微小的细节，比如交通信号灯，也能定义未来车辆的移动。我们可以从这张图片中推断出很多信息，只要我们仔细观察。

深度学习正在计算机视觉算法及其应用领域带来一场巨大的革命。这正在改变一切，从机器人技术、自动化、移动计算（每个人口袋里都有很多运行着计算机视觉模型的嵌入式硬件），到生物学、医疗保健（确保我们能够像人类一样从原始图像和原始医学图像中检测出病症），再到自动驾驶和辅助功能应用。大家将在这节课中看到的一个真正的主题是，这些计算机视觉算法，尤其是今天讲座中重点介绍的算法，是多么的普遍，因为它们真的无处不在。

### 计算机视觉的应用 (3:13 - 5:27)

你们将在今天的实验中接触到的一个例子是面部检测。这是计算机视觉最初的应用之一，在社区中产生了巨大的影响。它不仅能让我们检测出是否有人脸，还能检测出人脸的特征，理解人脸难以察觉和解释的微表情。当然，我们都听说过很多关于自动驾驶汽车的炒作和宣传。这是一个经典的计算机视觉问题。我们在这里所做的就是将图像作为输入。实际上，大家可以在这段视频的右下角看到输入的图像，这是进入网络的原始摄像头图像。这是一个端到端的网络，一个单一的模型。这实际上与大多数自动驾驶汽车的运作方式非常不同，它们通常由多个模型和预定义地图组成的流水线。实际上，这是我们在麻省理工学院完成的工作，我们制造了一辆自动驾驶汽车，它就位于这座建筑的车库里，它可以在全新的、从未见过的道路上完全自主驾驶，完全依靠视觉输入数据。

当然，我们已经稍微讨论过这一点，但我们将看到今天所学内容在生物学、医疗保健、医学等领域的应用。我想现在开始深入探讨今天课程的一些技术基础。我将首先说明，在幻灯片中展示的所有令人惊叹的东西，今天的课程将是这样一节课：我们将训练计算机视觉算法来完成的任务，很多时候是我们人类认为理所当然的任务。我们甚至不需要思考就能轻松地完成这些任务。我认为今天的讲座真正归结为一个问题：我们如何将我们所有人都认为理所当然的东西，也提炼到计算机中？

### 计算机视觉的技术基础 (5:27 - 7:35)

为了理解这一点，我们首先从最基本、最简单的情况开始，也就是理解计算机如何处理图像。我们甚至先不讨论处理，先说说计算机如何表示图像。

对于计算机来说，图像就是数字。实际上，图像比语言简单得多，因为图像已经表示为一个数组或列表，一个二维的数字列表。例如，如果我们有这张幻灯片上的亚伯拉罕·林肯的图像，它是由像素组成的。什么是像素？像素就是一个数字。由于这是一张灰度图像，每个像素都将由一个数字表示。如果这是一张彩色图像，每个像素将由三个数字表示，分别是红色、绿色和蓝色值，而不是单一的灰度强度值。所以我们可以把这张图片表示为一个二维的数字数组，每个数字对应图像中的一个像素。这就回答了我们的第一个问题：计算机如何“看到”图像。

如果我们有一张彩色图像，就像我说的，它将不是一个二维数组，而是一个三维数组。它将是二维的，再乘以第三个维度，也就是颜色轴，对于大多数图像来说，颜色轴的长度总是3。这就是我们今天课程的其余部分将要使用的图像表示方法。

### 机器学习任务：回归与分类 (7:35 - 8:18)

我们将重点关注两种常见的机器学习或深度学习任务，实际上在整个课程中都会用到，但特别是今天。这两个任务分别是回归和分类。

让我们从这两个任务开始。首先，对于回归，什么是回归？回归允许我们在系统中输出一个连续值。另一方面，分类允许我们输出一个类别标签。

例如，这里看到的图像可以映射到一个分类问题。假设我们想要检测这张图像来自哪位美国总统，答案可以是 K 或 N 个不同类别中的一个。这些是离散的类别，你可以是这 N 个类别中的一个。

### 特征检测 (8:18 - 10:16)

为了正确地对左侧的图像进行分类，我们的模型需要能够做什么？或者说，为了我们自己作为人类能够做到这一点，我们需要能够做什么？我们需要理解右侧每个类别的独特之处。是什么让亚伯拉罕·林肯的照片与乔治·华盛顿的照片不同？如果我们再次理解这些独特的特征，那么我们就可以在左侧的图像中寻找这些特征。但第一步实际上是我们需要提取和定义我们在每个不同类别中寻找什么。

这就是特征检测的任务。特征检测的意义在于理解是什么让一个类别不同于另一个类别。另一种思考方式是，想象一下分类是通过一个两步过程完成的：首先，定义你要在图像中检测什么；然后，检测这些东西。如果你检测到足够多的这些东西，那么你就可以把它归类为那个对象。

例如，假设我们要检测一张人脸的图像，你可能会寻找眼睛、鼻子和耳朵等特征。如果你在图像中检测到足够多的这些特征，那么你就可以有信心认为你可能正在看一张脸。另一方面，像房屋这样的东西是由门、窗和台阶等特征定义的。如果你在图像中寻找这些东西，你就可以有信心认为你已经识别出了房屋（如果你成功地找到了它们）。所以，如果你正在构建一个图像分类器，它实际上归结为这一点：你首先要定义你的特征，知道你要寻找什么，然后你寻找这些东西。如果你找到了它们，那么你就可以成功地对图像进行分类。

### 计算机视觉的难点 (10:16 - 11:46)

现在，说起来容易做起来难。因为解决“知道你想要检测什么”这个问题的一种方法，这是一个很大的问题，因为知道你想要通过寻找眼睛来检测人脸，现在你又有了如何检测眼睛的问题。这是一个递归问题。现在你有了与检测人脸相同的问题，即检测眼睛。这是一个分层的问题。除此之外，它还是一个存在许多不同变化和适应的问题。你可以想象，人脸看起来完全不同，这取决于你的视角、尺度、遮挡以及不同的光照和照明等等。

在像素空间中，即使是同一物体用两台不同的相机拍摄，也可能看起来非常不同。这就是为什么计算机视觉对计算机来说如此困难，尽管我们认为这一切都是理所当然的。

所以我们的分类算法，我们在这节课中构建的模型，必须能够对所有这些不同的变化和特征空间中的所有这些不同的修改具有不变性，也就是对我们在图像中寻找的东西具有不变性，以便构建一个非常鲁棒的流水线。如果我们没有这种适应性或对这些特征的不变性，那么我们将无法在检测中非常鲁棒。

所以实际上，这一切都归结为这里的最后一个要点：为了分类而进行的特征检测通常是机器学习崩溃的地方，也是深度学习开始发挥作用的地方。

### 深度学习的作用 (11:46 - 13:29)

机器学习使得检测这些特征变得非常困难，因为在机器学习中定义特征是一个人工过程。而在深度学习中，我们会说，我们要使用数据来定义这些特征。那是什么样子的呢？

使用神经网络，我们可以开始说，与其让我作为一个人类来定义，说我想通过寻找耳朵、眼睛和鼻子来检测人脸，然后再递归地定义，再进一步，我如何找到错误？我会寻找垂直线，然后是线下面的一个圆圈，诸如此类的东西。我不会作为一个人类来定义任何这些。我会向我的模型展示很多张人脸的图像，它应该能够提取出所有这些人脸图像的独特之处，帮助我将所有这些人脸图像与汽车图片区分开来。比如说，区分这两者的独特特征和独特的像素样式是什么？让我们以分层的方式来做。这里的层次结构来自模型中的层。模型的深度决定了层次结构，每一层深度都是由上一层组成的，这使得我们能够注入另一层复杂性或表达能力，就像我们昨天看到的那样。

现在，神经网络所做的就是允许我们隐式地学习这种层次结构，而不是显式地定义，而不是由人类手动构建它们。

### 全连接网络的问题 (13:29 - 15:46)

在第一讲中，我们学习了如何使用全连接网络来完成这种类型的任务。实际上，到目前为止，这听起来应该并不新鲜，因为我们一直在讨论的只是一个多层网络的组合，其中每一层都是由前一层的输出组成的，每一层中的每个神经元都将简单地连接到前一层中的每个输入。

假设我们想使用我们在第一讲中学到的知识来解决我们现在看到的计算机视觉问题，我们该怎么做呢？我们实际上可以尝试一下。在我们的例子中，与第一讲不同的是，现在我们有一个二维输入。在第一讲中，我们只有一维的特征输入到我们的模型中，但现在我们有两个维度，因为我们有一张图像。所以让我们把这个二维输入输入到我们的全连接网络中。这会是什么样子呢？

我们已经遇到了一个问题，因为我们必须把我们的二维图像展平为一维输入，因为我们所有的全连接网络只能处理一维输入，这是我们在第一讲中学到的。所以，使用全连接网络进行图像处理任务的唯一方法就是将图像转换为这些全连接网络能够处理的形状。

现在，希望在座的每个人都能理解和认识到，之前存储在这种非常丰富的图像数据类型中的100%的空间信息现在完全消失了。我们通过展平它破坏了100%的空间信息。此外，我们在这个模型中还有很多参数，因为输入层中的每个像素都将连接到隐藏层中的每个神经元，而这只是一层，然后你还有很多层。

所以我们得到的是一个非常昂贵的模型，但实际上是一个次优的解决方案，因为我们丢弃了很多非常有价值的空间信息。

### 卷积的引入 (15:46 - 17:53)

所以，我们想要做的是问右下角的这个问题：我们如何保留和利用数据中存在的这些非常丰富和独特的空间信息？这只是数据的一部分，只是为了告知我们的网络架构，我们不想毫无理由地丢弃所有这些信息。我们想要利用它并增强我们的能力。

为此，让我们实际上将我们的二维图像表示为它的真实形式，让我们将它表示为一个二维的像素值数组。我们现在想要使用输入中固有的空间结构的一种方法是，将输入像素以“块”（patch）的形式连接到我们的神经元。之前我们将所有东西都连接到一起，但实际上，我们现在要改变的是，我们将保持二维结构，但我们只会将输入像素空间中的东西连接到输出神经元，这些输出神经元以逐块的方式局部连接在一起。

例如，这里的这个神经元将只接收来自左侧这个“块”的像素的局部连接结构的输入。同样，这实际上在整个图像上重复。你在这个左上角看到的这个“块”将产生这个输出神经元，但紧挨着它的下一个输出神经元将由下一个“块”定义或引导，这个“块”向右移动了一个位置。所以现在不是所有东西都连接到一起，信息仍然有很多重叠，因为你会看到这个神经元确实与这个神经元共享了很多输入像素，存在重叠，但不是整个模型的完全连接。我们成功地保留了大量的空间信息。我们基本上通过定义强制执行了这一点，即输出层中彼此靠近的神经元将来自输入层中彼此靠近的像素。这就是我们保留空间信息的方式。

### 卷积操作 (17:53 - 19:11)

实际上，我们刚才讨论的只不过是一个数学运算，叫做卷积。什么是卷积？让我们首先从高层次上思考一下。假设我们有一个这里表示为 4x4 的卷积核，我现在将使用“卷积核”这个词。

卷积核就是你可以看到这个红色框，我将把它称为卷积核。这将由 16 个（也就是 4x4）像素权重组成。所以你将有来自图像的 4x4 像素，你还将有来自卷积核的 4x4 权重。然后这个东西将在我的图像上逐步滑动，并应用我们在第一讲中看到的相同操作：逐元素相乘，添加偏置，应用非线性函数。这里没有区别，只是不是所有东西都连接到一起，你只会在卷积核级别执行此操作，而不是对所有东西，而是对这些 4x4 的卷积核，当你在图像上移动时。我们将在每次执行此操作后移动我们的卷积核，一遍又一遍地移动，比如说移动一个像素或两个像素，以便我们可以扫描整个图像。

### 卷积如何提取特征 (19:11 - 22:30)

现在你可能已经在想，在这个基础上的下一层复杂性将是真正理解卷积操作实际上如何允许我们提取这些特征。到目前为止，我只定义了卷积操作是如何工作的，但它是如何让我们定义我们在讲座开始时谈到的内容呢？我们想要定义我们应该在图像中寻找的东西，卷积操作如何让我们提取这些信息？

让我们通过几个例子来具体说明这一点。假设我们想要从一组黑白像素中分类或检测“X”。这些只是图像，它们是二维的数字数组。在这种情况下，它们不是灰度的，它们只能是黑色和白色，所以每个像素要么是 +1，要么是 -1。我想构建一个模型，可以确定左侧是否等于右侧。我有一些“X”的例子，我在右边看到这个新的例子，它是一个有点倾斜和旋转的“X”，它不是一个完美的“X”，所以我不能简单地将像素叠加在一起进行比较，我必须更智能地检测它们。

我们想要做的是，即使右边的东西被移动、缩放、缩小、旋转、变形，无论是什么情况，我们仍然希望能够非常可靠地检测出它们是否是“X”。让我们思考一下。我们如何使用我们刚才看到的相同原理来做到这一点？我们可以让我们的模型不是全局地比较“X”，而是逐块地比较。如果我们观察感兴趣的关键“块”，也就是定义“X”的东西，实际上只有少数几个东西定义了“X”：一条对角线是这样的，一条对角线是那样的，然后是两条线的交叉。

所以在这里，你可以看到我们正在寻找的三个特征：我们正在寻找一条从左到右的对角线，一条从右到左的对角线，以及一个交叉点。如果我们逐块进行比较，实际上你可以看到，即使这些特征，这些我们正在检测的东西，它们可能位于不同的位置（例如，绿色的对角线不在完全相同的位置，但非常接近），但我们仍然能够检测到这些特征。如果我们的模型能够在“块”级别上找到大致的匹配，那么我们就可以成功地检测到定义“X”的东西，从而让我们有信心说，“这可能也是一个全局的‘X’”，如果我能找到足够多的这些模式。

每个特征基本上就像一个“迷你图像”。它是一个微型的、二维的数字数组，与大图像没有什么不同。但我们将使用这些卷积核来定义和检测这些“块”。在这种情况下，这些“块”或卷积核代表了我们看到的对角线和线的交叉，这些都是构成“X”的重要特征。但在实践中，我们可能希望捕捉这些特征，以便应对任何新的“X”，而不仅仅是这一个“X”，并且它们对这些类型的扰动是鲁棒的。

### 卷积的数学表示 (22:30 - 24:52)

让我们继续深入探讨，并开始介绍一些数学术语，以便大家可以开始熟悉，并了解如何将过去几张幻灯片中看到的直观概念转化为接下来几张幻灯片中的数学。卷积做什么？卷积操作所做的正是我们在过去几张幻灯片中直观地看到的。它通过将大图像分解为较小的子图像，然后在这些子图像中搜索关键信息，从而保留图像中存在的空间信息。

为此，它基本上在它正在寻找的东西和原始图像之间，沿着图像的每个点进行逐元素相乘。假设它正在寻找这条从左到右的对角线。卷积核将是左上角看到的这个 3x3 的微型图像。这是一个 3x3 矩阵，一个二维矩阵，但它是 3x3 的。在这种情况下，这里的所有条目，或者说，所有的条目都是 -1，除了对角线是 +1，这是因为我们正在寻找这条对角线。我们将这个卷积核（这是我们正在寻找的东西）与图像中的每个“块”逐元素相乘。所以我们将从这里开始，这是实际的“块”。我们将在这里观察，我们将左上角的“块”与这里的像素“块”逐元素相乘。当我们把左上角的每个数字与这个绿色框中的每个数字相乘时，我们将得到另一个 3x3 矩阵，其中的所有元素都等于 1，因为左上角卷积核中的每个像素与我们的图像“块”中的每个像素都完全匹配。

现在我们得到了逐元素相乘的结果，我们将执行我们在第一讲中看到的操作：我们将逐元素相乘的结果相加，并将它们通过一个非线性函数（我们稍后会看到）。

在继续之前，让我们再考虑一个例子。

### 卷积的计算 (24:52 - 26:33)

假设我们想要计算这个 5x5 图像（绿色）与这个 3x3 卷积核（黄色）的卷积。为此，我们需要用这个卷积核覆盖整个图像。我们可以通过逐步地、逐块地在整个图像上滑动卷积核来做到这一点，然后在每一步执行相同的操作：逐元素相乘和加法。

让我们看看这是什么样子。首先，我们从左上角开始。我们将黄色的卷积核放在图像左上角。我们对那个 3x3 的“块”与该 3x3 位置的所有像素进行逐元素相乘，然后将所有这些条目相加，我们得到结果 4。我们将把这个结果放在这个神经元的位置。这是我们网络第一层左上角神经元的输出。然后我们向右滑动一步，再次执行完全相同的过程。现在与这个卷积核的重叠稍微少了一点，所以我们将看到紧挨着它的这个神经元的输出是 3。我们可以一遍又一遍地重复这个过程，直到我们滑过整个图像并覆盖所有“块”。

就是这样。现在我们所做的就是定义了一个操作，可以从左侧的输入图像开始，给定一个输入图像和中间的卷积核，定义最右侧的输出层是什么。

### 卷积核的选择和学习 (26:33 - 28:43)

（提问）你选择什么卷积核？

（回答）完全正确。到目前为止，我们还没有讨论过这一点。我们所说的只是，给定一个图像和一个卷积核，我们定义一个操作来计算输出结果。你是完全正确的，下一步是说，我们想要学习这些卷积核，因为卷积核实际上决定了你能得到多好的输出结果。这实际上是可调参数，它将决定整个过程。我们将在讲座的下一部分讨论这个问题。

（提问补充）这是一个很好的问题。实际上，为了激发这一点，我的意思是，你可以做几件事。很长一段时间以来，人们都是手工设计这些卷积核的，你甚至不需要学习它们。如果你想检测线条，实际上有一些非常好的卷积核，你不需要学习它们，设计一个可以检测边缘的卷积核很容易。这是一个可以检测从非常高的亮度值到非常低的亮度值的变化的卷积核，它是一种导数卷积核。事实上，多年来，人们已经手工设计了卷积核来服务于不同类型的目的。

在这里，你可以看到不同卷积核的一些例子。给定左侧的输入图像，你可以看到这些是手工设计的卷积核，用于锐化图像，手工设计的卷积核用于检测边缘，甚至更强的边缘检测。如果你观察这些卷积核，你实际上可以有意义地解释它们。锐化卷积核放大了中心，然后最小化了边缘。当它在“块”上滑动时，你会得到锐化效果。边缘检测卷积核又是导数的一种形式，效果有点相反。所以，正如问题所暗示的，仅仅通过改变卷积核的权重，你就可以完全改变下一层的输出。所以卷积核非常重要，定义你的卷积核可以对寻找图像中你真正关心的东西产生很大的影响。

所以希望现在大家非常清楚地理解了，不仅是关于我们如何计算卷积的输出，还有保留所有这些空间结构并通过卷积操作保持这些结构的重要性。

### 卷积神经网络 (CNN) (29:36 - 31:49)

现在我们已经掌握了所有关于卷积操作的知识，我想现在是时候转换一下思路，说，我们如何理解不仅仅是卷积操作的作用，还有我们如何开始定义卷积操作的输入。我们已经看到，输入图像是明确定义的，我们将其作为模型的输入，但卷积核本身呢？为了做到这一点，我们可以稍微放大一点，看看我们最终将得到一个完整的卷积神经网络。

让我们考虑一个简单的 CNN，CNN 代表用于图像分类的卷积神经网络。这里的目标是从图像数据中学习这些卷积核或特征（它们是同一个东西，两个词只是不同的说法）。所以，给定左侧的一堆图像，我们想要学习能够区分右侧不同类别的卷积核或特征。

CNN 有三个主要操作。我们已经看到了其中一个，对吧？第一个是卷积。卷积定义了这种逐块处理图像的操作。第二个我们已经暗示过了，它是在每次卷积之后应用的非线性。最后，第三个是池化，这只是一个下采样操作，允许我们扩大我们的感受野。因为如果我们在图像上逐块执行此操作，我们还需要有不同层次的深度，比如我们的“块”有多大。所以通过对图像进行下采样，我们实际上以相同的方式对我们的“块”进行了上采样。

我们可以在一组图像上训练我们的模型，在训练过程中，我们将学习这些卷积核。现在我们将更深入地讨论这一点，但是当我们用这个框架定义模型时，我们在这里所做的只是通过反向传播，你定义所有的操作，你展示数据，然后你可以计算出能够最优地解决这个任务的最优权重集合或最优卷积核集合。你通过优化来做到这一点。

### CNN操作的细节 (31:49 - 34:02)

让我们逐一介绍这些操作，以便进一步分解，并更具体地看看这是什么样子。让我们更深入地研究 CNN 中的操作。正如我们之前看到的，我们隐藏层中的每个神经元（也就是我们模型第一层的输出）将通过输入与卷积核的加权和来计算。我们应用一个偏置，我们将所有东西相加，然后应用我们的非线性函数。

现在，这里特别的是，我想强调局部连接这一点。局部连接允许右侧隐藏层中的每个神经元只“看到”左侧输入像素的“块”。这非常重要，因为现在我们可以真正地用数学来定义这个计算。从我们之前看到的所有图示来看，对于隐藏层中的一个神经元，它的输入是前一层“块”中的神经元。那是什么样子的呢？我们可以应用这个权重矩阵，我们也一直称它们为卷积核或特征，在这种情况下，这是一个 4x4 矩阵，来执行逐元素相乘。我们对输出求和，应用偏置，并应用我们的非线性函数。和之前的故事一样，但请记住，我们的逐元素相乘和加法只不过是卷积，这正是我们之前讨论的卷积。

这定义了神经元如何在正向传播中操作，但是在卷积层中，我们不只是对一个卷积核执行此操作。每一层都对一整套卷积核执行此操作。所以你可能会说，一层正在寻找各种不同类型的边缘，它可能会学习寻找各种各样的边缘的卷积核，然后在下一层中使用这些卷积核来检测许多不同类型的边缘。所以你实际上会在这张幻灯片中看到，你不仅仅是输出卷积核输出的一个二维图像，你输出的是一个完整的“体积”，“体积”不仅仅来自一个卷积核，而是来自整个深度方向上的卷积核。这只是你的卷积神经网络的一层。你网络中的一层将输入（再次强调，是一个“体积”，但在第一层，我们只称它为图像）作为输入，它在该图像上检测 N 个不同的卷积核。它会给你返回一个新的“体积”，这个“体积”是该图像与这 N 个卷积核进行卷积的结果。

### 非线性 (34:02 - 35:20)

在我们得到那个“体积”之后，我们下一步要做的就是计算，或者说，将它们全部通过我们的非线性函数。这为我们提供了非线性能力和表达能力，这是我们在前两讲中讨论过的，也是我们关心的。

现在，对于图像来说，一个常见的应用是使用像 ReLU（整流线性单元）激活函数这样的非线性函数，你可以在这里看到。你为什么可能想要这样做呢？这是因为 ReLU 激活函数基本上是一种阈值函数。它消除了所有负值，将所有负值压缩为零，并保持所有正值不变。所以你可以把它想象成在计算机视觉中具有非常直观的意义，它是一个阈值函数。你只想消除所有东西，并将其全部压缩为正值。

### 卷积和非线性的关系 (35:20 - 36:19)
- 卷积的步骤是为了检测出输入中的特征。
- 非线性是为了增加这些检测特征的表达能力，以进行非线性检测。
- 在第一步中你不做任何更多的卷积，但是你的深度网络有很多层。所以每一层都执行一次卷积运算，但随后你会按顺序将它们堆叠起来。

### 池化 (38:50 - 40:17)

（提问）卷积会不会改变图像的空间分辨率？

（回答）不一定。卷积不一定会改变图像的空间分辨率。你可以用不同的方式实现卷积。但在现在的例子中，如果你在图像上传递卷积核，通常卷积核比你的图像尺寸小得多，所以你的输出尺寸分辨率将大致与你的输入图像尺寸相同。

空间分辨率不会随着卷积而改变。有一些不同的实现方式可能会导致不同的结果，我们现在不必深入讨论。但总的来说，我们可以这样说：你改变空间分辨率是为了进行多尺度的特征检测。你做一次，你正在检测一个尺度的特征。然后你缩小这个“体积”，然后你再次重复。下次你重复它时，你现在正在检测更大尺度的特征，因为你现在已经缩小了你的“体积”。这个重复的过程允许你不仅在原始尺寸上检测特征，还可以在许多尺寸上重复检测。并且也让这些特征相互复合。你可能希望你的特征是分层的，所以你想说，我不只是想检测边缘这些非常基本的特征，我还想组合这些边缘。只有当我从第二次卷积的输出中获取它时，这才是可能的，而不是第一次卷积，因为你想要检测的组合，而不仅仅是原始的检测。

(提问) 卷积核总是不一样吗？

(回答) 是的。卷积核总是不同的，因为卷积核是学习的，而不是由人类定义的。所以在一个层内和跨层，卷积核总是不同的，因为它们将被随机初始化，然后通过数据进行优化。所以当一切都完成后，你将拥有一组卷积核，它们在整个网络中彼此之间几乎没有重叠，除非你有一个巨大的网络，你必须有重叠。

(提问) 基本上是这样的。

(回答) 是的。我们将看到一些例子。实际上，让我向前翻几张幻灯片，因为这很快就会变得更加明显。

我们已经讨论过这一点了，但是为什么我们在卷积之后做一些事情呢？我们做这个池化操作。池化只不过是缩小我们的维度。在每次卷积之后，我们得到一组检测到的特征的输出。我们缩小这些特征，然后我们再次重复卷积，因为下次我们进行卷积时，我们将拥有更大的感受野，因为我们的输入图像现在更小了。

这里一种常见的下采样技术叫做最大池化。这基本上就是说，你将在左侧取一个“块”，你将从该“块”中选择最大值，并将其放入这个 2x2 的区域中。从 2x2 的区域中，你将把它放入一个 1x1 的单一最大值中。有很多方法可以进行池化和降维。最大池化只是一种方法。你可以考虑一些对导数不那么“严厉”的方法。最大池化实际上非常“严厉”，因为导数不会通过 3/4 的像素。通过这样做，你只会通过激活最大值的那个像素获得导数。想象一下，如果你改为进行平均池化，你将在整个“块”中获得稳定的梯度。所以你可以考虑一些巧妙的方法来进行其他形式的下采样。这是一个非常开放的问题。

### 可视化卷积核 (40:22 - 41:53)

但是回到这一点，关于我们如何解释和查看正在学习的卷积核，实际上你可以在模型训练时或模型训练后可视化这些卷积核。所以你实际上可以看到卷积神经网络，卷积层正在优化自己来检测图像中的什么。

这是一个卷积神经网络学习检测人脸的例子。你基本上可以看到这个网络激活的卷积核的三个不同层次。在开始时，它正在寻找基本上是这些边缘，就像不同方向的强度值变化。当你向上移动模型时，你开始将这些卷积核和正在分层提取的特征组合在一起。你实际上开始看到面部特征开始出现，比如我们之前谈到的眼睛、鼻子和耳朵。然后你再向上移动，你开始看到完整的结构开始出现。

现在，CNN 与机器学习的关键区别在于，我们没有自己定义任何这些卷积核。我们通过向模型展示大量数据来学习这些卷积核，并询问模型，“为了让你尽可能准确地检测人脸，你应该使用哪些卷积核？”我们只在它无法检测到人脸时惩罚它，我们说，“继续改变你的卷积核，直到你能够更好地检测人脸。”这就是它得出的结果，这些是它为了最准确地完成这项任务而学习检测的东西的卷积核。

### CNN的两部分 (42:01 - 42:31)

所以，现在整个过程大致分为两个部分：第一部分是使用那些学习到的卷积核提取这些特征；第二部分是使用这些特征进行某种形式的检测。在这种情况下，我们正在讨论面部检测。所以有这两个部分：我们如何利用第一阶段从模型中学习到的特征来为我们的分类阶段提供信息？

### Softmax函数 (42:31 - 42:55)

我们可以使用一个叫做 Softmax 函数的函数来做到这一点。什么是 Softmax 函数？这只是一个函数，它接受最后一层的 N 个输出，并将它们压缩为总和为 1。我们为什么要这样做？因为在这种情况下，我们关心的是分类。如果你想对某些东西进行分类，你必须有一个概率分布。什么是概率分布？你必须有总和为 1 的质量。

### 构建CNN代码 (43:01 - 44:31)

现在让我们把所有这些都放在代码中，来构建我们的第一个端到端卷积神经网络。我们可以从定义我们在上一张幻灯片中看到的网络的两个部分开始。第一部分将是特征提取部分，这是包含所有卷积核的部分。这将有 32 个特征图，你可以在这里看到。所以从第一层出来的第一个“体积”将有一个深度为 32 个特征的“体积”，对应于在第一层中学习到的 32 个卷积核。我们将下采样空间信息，然后将其传递到另一个卷积层，该卷积层接收这 32 个特征，并在更小的维度上学习另外 64 个特征。然后我们将所有这些展平。现在我们可以移除我们的空间信息，我们进入一个一维空间，因为现在我们实际上想要对分类进行一维预测。所以我们展平所有东西，因为我们已经学习了我们的空间信息，然后我们投影到一个 Softmax 函数，该函数允许我们预测我们的概率分布，并允许我们输出我们最终的，比如说，10 个类别。如果我们试图预测数字，我们将有 0 到 9 个不同的类别，总共 10 个类别。

在 PyTorch 中，你将看到一个非常相似的代码版本，几乎与你之前看到的相同。我们再次定义了卷积层（32 个特征，然后是 64 个特征），一个展平操作，允许我们进入一维空间，然后传递到我们的最终输出维度。

### 关于超参数的选择 (44:31 - 45:53)
(提问) 你能说几句关于你如何选择这些参数的吗？“块”的大小是3，有32个特征图和层。这些参数更像是一门艺术而不是科学吗？

(回答) 是的，它是一门艺术，但它也可以通过大量的直觉来指导。我将提供一些直觉：通常你希望你的特征，特别是根据任务，开始时非常小，但你希望保留，你希望随着模型深入而增加空间信息。所以你要确保你首先了解，根据你的图像，根据你的数据集，你要了解，作为一个人类来看，这个模型应该在开始和结束时查找的特征的规模是多少。这些将基本上定义这两个分辨率。如果你说，这是一张巨大的图像，假设是 2000x2000 像素宽，那么从 3x3 开始就太小了，对于大多数图像来说可能都是如此。如果你的图像是 2000 像素宽，那么查看这么小的尺度是没有意义的。但随后可能会有其他应用，图像非常小，甚至 3x3 已经是图像中一个重要的分辨率了。所以这非常依赖于具体问题。

### 关于训练数据和测试数据的差异 (45:53 - 46:36)
(提问) 如果你用直立的人脸训练它，然后你在侧面的人脸上测试它会怎样？

(回答) 不会。在这种情况下，我们不期望它会表现良好，因为它已经学会了检测始终是直立的人脸的特征。如果它被展示了两种方向的人脸，那么我们期望它会成功地做到这一点，因为我们期望它应该学习到人脸可以是任何一种方向。所以它应该学习在两种情况下都挑选出这些特征。

### 关于可变形物体 (46:36 - 47:15)
(提问) 这种方法对于可投影的对象（例如，枪、熊或流体模拟）如何工作？

(回答) 这非常依赖于具体问题，但我们仍然希望确保我们可以从数据中学习。即使在这些更动态的情况下，我们稍后会在幻灯片中看到一些例子，关于这些类型的情况。但实际上，我们希望确保这些都是可以从数据中学习的。

### CNN的应用扩展 (47:15 - 48:09)

好的，我将继续，因为我们还有很多内容要讲。到目前为止，我们只讨论了用于分类任务的 CNN，但实际上，这种架构远远超出了分类。还记得我之前给大家看的这张图片吗？我认为这是一张非常有帮助的图片，因为它将所有 CNN 分解为两个部分：一个特征提取器，以及我们之前看到的分类器。但实际上，第二部分可以是任何东西。你可以使用一个特征提取器，并将其与一个对象检测器、一个分类器、一个分割模型、一个概率控制模型、一个回归模型等等一起使用。所以在这部分，我们实际上将看看你可以创建的所有不同类型的模型，只需保持左侧不变，使用相同的特征提取器，但现在让我们看看，如果我们改变右侧，我们如何实现许多非常不同的事情和看起来非常不同的不同类型的模型，但实际上它们并没有那么不同。

### 分类 (48:09 - 48:41)

在分类的情况下，我们已经看到了这一点。网络的右侧部分只不过是对我们所有特征的展平操作，然后我们对 N 个不同的类别进行分类。例如，这里你看到一个基本上是二元分类的例子，诊断或不诊断。这是一篇几年前发表的论文，基本上证明了 CNN 在这些类型的诊断任务中可以胜过放射科医生，用于乳腺癌图像。

### 目标检测 (48:41 - 50:18)

分类是二元问题，或者说是 K 类问题，它不一定是两个类别，但可以是 K 个类别。让我们更深入一层。这是一张出租车的图像。分类就是我说，“我输入这张图像，我预测出租车”。目标检测呢？

目标检测不仅仅是预测“出租车”这个类别，它还会预测更多的东西。它会预测该对象的位置、该对象的类别以及一个精确的边界框。所以它不仅仅是对象中心的位置，它是该对象整个边界框的位置。神经网络必须告诉我们，不仅仅是对于这一个对象，而是对于这个场景中的每个对象，它在哪里，以及该对象的类别。

所以我们的模型必须非常灵活才能完成这种类型的任务，因为它现在不仅仅是输出 N 组不同的输出或 K 组类别。如果场景中只有一辆出租车，它将输出一个边界框。但另一方面，如果图像有很多对象，它应该足够灵活，也能有很多输出。甚至这些输出也可能有不同的类别，显然不同的位置，不同的数量和顺序。所以我们如何才能完成这样的事情呢？

### 目标检测的难点 (50:18 - 50:36)

这非常复杂，因为第一，我们看到的那些框可以位于图像中的任何位置，它们可以是任何大小，它们可以是任意数量的。你的图像中实际上也可能没有框。

### 朴素方法 (50:36 - 51:49)

让我们首先考虑一个非常朴素的方法。让我们拿我们的图像（左侧），让我们首先在图像上放置一个随机框。我们将放置一个随机的，我们将选择一个随机框，我们将把它放在那张图像上，我们将把那个随机框传递给我们之前训练过的 CNN，特征提取器，然后我们将以旧的方式使用那个特征提取器，我们将把它用作一个分类模型，即使我们讨论了所有关于使这个模型非常灵活的东西，我们首先将以旧的方式做到这一点。但我们将重复这样做，我们将不断选择随机框，我们会说，“这个框里有什么东西吗？没有，好的，转到下一个框。”我们将一遍又一遍地这样做，对于图像中足够多的框，我们将用一堆分类填充整个图像，如果没有检测到类别，就简单地丢弃该框。

现在，这有很多问题，但主要的问题是，这里的输入太多了。这将是计算成本非常高的，即使对于任何实际的图像，你永远也无法完全覆盖整个图像，以及所有类型的框。框的数量相对于分辨率呈指数级增长，所以你不能简单地使用这种朴素的方法。但它给了我们一个很好的起点。

### 启发式方法 (51:49 - 52:32)

与其选择随机框，如果我们更智能一点，使用启发式方法呢？实际上，我们可以构建一些非常简单的启发式方法，在图像中选择看起来像是有东西发生的区域周围的框。你不需要了解图像的任何信息，但只需寻找图像中的“斑点”，你就可以创建一个相当不错的启发式方法，它可以识别出，“这是图像中一个可能有趣的部分，我将在它周围画一个框，并将其传递给我的分类器。”但实际上，这仍然非常慢，因为我需要绘制很多框才能使其工作良好，而且我们必须将每个框独立地输入到我们的分类模型中。所以它非常脆弱，因为现在我们也完全断开了问题的这两个部分。我们还讨论了很多关于从特征检测到分类的端到端模型，但现在我打破了那个模型。我说，“我要在这里有一个框提议模型，它将为我提议框，我将有另一个分类模型，它接收框并处理它们。”但是，如果，你知道，理想情况下，我们希望这两个模型共享信息，以便预测好的框，它应该在高层次上知道它在寻找什么。

### R-CNN方法 (52:32 - 54:28)

所以我们如何解决这个问题呢？这是一种你将看到和听到很多的方法，我将非常简要地介绍它，以便每个人都熟悉它。它被称为 R-CNN 方法，也就是区域卷积神经网络方法。它试图做的是实际上学习那些区域，那些框。它试图在与分类这些框的模型相同的网络中学习它。这是什么意思呢？这意味着我们可以从底部开始，我们从原始图像开始，我们有这个区域提议网络。区域提议网络将图像作为输入，并提议区域。它学习提取图像中高重要性区域的特征。这用于定义我用于分类模型的框。所以，我获取这些区域，我在它们周围绘制框，然后我将它们通过相同的分类器，使用学习预测这些区域的相同特征。所以现在在这个整个过程中有了很好的端到端对齐。现在只需要一次前向传播就可以完成整个模型。所以与我们之前看到的模型相比，它非常高效，而且非常准确，因为它实际上在这个过程中共享特征。

### 语义分割 (54:28 - 56:14)

在分类中，我们看到我们比分类更进一步，我们进入了目标检测，它比分类更进一步。我们现在甚至要比目标检测更进一步，进入分割。所以，与其仅仅预测图像中的框，如果我们预测我们图像中每个像素的类别呢？所以现在，给定左侧的图像，我们想要预测右侧的另一个图像，其中包含该图像中每个像素的分类值。

这里只是展示了一个例子，这是一个语义分割模型。“语义”意味着我们正在学习左侧 RGB 图像中每个像素的语义，也就是类别。所以在这里，你可以看到基本上是一张左侧奶牛的图像，被语义分割成几个不同的类别：草地、奶牛，看起来还有背景中的树木和天空。

这是怎么做的呢？网络的左侧部分是我们之前看到的相同的特征提取器。它由卷积、下采样和非线性组成。后半部分不再是一维情况下的分类模型，但现在它将所有东西都保持在二维，但现在它是上采样卷积。所以，与其进行卷积然后下采样，我们进行卷积然后上采样。我们再次学习最右侧的输出，只是所有这些的分类。所以这只不过是另一个分类问题，我们没有下采样到一维，我们只是将所有东西都保持在二维，我们使用了上采样而不是下采样。

### 自动驾驶 (56:14 - 59:07)

让我们看最后一个例子。假设我们想要学习一个用于自动驾驶的神经网络，就像我们在课堂开始时看到的自动驾驶汽车。让我们具体地说，我们想要学习一个模型，可以从原始感知摄像头数据以及嘈杂的街道视图地图（比如说，就像你在手机上的谷歌地图上得到的那样）开始。这些是汽车在那个时间点的鸟瞰图，但它们只是图片。你想要将这两者都输入到一个神经网络中，并允许神经网络根据这两条信息学习如何驾驶。

如果你仔细想想，实际上这也是人类驾驶所需要的全部。我们也只使用视觉和谷歌地图。如果我们去一个新的城市，我们需要一些导航信息层来驾车穿过那个城市。我们想要的是直接推断出，不仅仅是一个方向盘角度，方向盘应该在哪里，我们想要推断出一个完整的概率分布。这又是一种分类问题，但现在我们不仅仅是预测 K 个离散类别，我们要学习一个连续的概率分布，因为方向盘角度是连续的，它们可以是任何值，比如说，从 -180 度到 +180 度，这是一个连续值。

可以使用我们今天学到的完全相同的技术来训练整个模型。我们可以将左侧的每张图像通过我们已经学习过的相同类型的模块，这些是卷积层，然后是非线性，然后是下采样。所有这些都为我们提供了来自每张图像的特征。在输出端，我们将所有这些特征组合在一维中，然后我们使用它来学习车辆的控制参数。然后我们通过反向传播进行回归，我们学习特征和卷积核，这些特征和卷积核对于这种类型的任务是最优的，通过观察大量的驾驶数据并学习，“为了成功地完成这项任务，我应该学习哪些好的特征？”

最终的结果是，这是一辆从未在这条路上行驶过的自动驾驶汽车，它实际上可以在全新的、从未见过的道路上行驶，没有地图。这实际上与你看到的 Waymo 汽车、谷歌汽车非常不同，因为它们需要由人类先在一个城市中驾驶一次，然后才能自动驾驶。人类不是这样操作的，我们可以被放在一个全新的城市中，第一次就可以成功地在那个城市中驾驶，而无需事先看到它。这种类型的模型也能够表现出这种类型的行为。

### 总结 (59:07 - 1:00:59)

CNN 的影响非常广泛，超出了我们今天讨论的这些例子。但希望大家能够理解，在所有这些例子中，实际上它们都来自完全相同的基本技术：卷积操作本身，特征学习来学习那些卷积核，然后是一些组合，要么是上采样，要么是下采样，来保留或调整空间分辨率。

所以我想现在基本上总结一下所有这些。首先，我们考虑了计算机视觉的许多起源。我们回顾了图像是如何表示的，它们被表示为这些二维的值数组。我们更进一步，说，我们如何使用卷积从这些二维数组中学习，以提取有意义的数据片段，然后将其构建成完整的网络，而不仅仅是单个卷积操作。然后是许多应用，使用卷积层的骨干，可以非常容易地衍生出许多不同类型的模型，从分类到检测到分割，还有许多其他的模型。

我将在这里暂停一下，然后我将过渡到 Ava，她将讨论生成式深度学习，这实际上是关于我们如何，这是我们在这节课中完全没有讨论过的一个全新的东西，不仅仅是我们可以从数据中学习，而是从数据中学习来生成更多的数据。这是一种非常不同的，它不仅是一种不同类型的模型，而且是与我们迄今为止在这节课中看到的所有东西完全不同的范式。所以我们将休息几分钟，我们将进行过渡，然后我们将在大约 2 分钟后继续。谢谢大家！
